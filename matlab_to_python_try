import numpy as np
from scipy.io import loadmat
from collections import defaultdict
import math
import pickle
# Function to load the data and convert it
def load_and_convert(filename):
    # Load the MATLAB file
    data = loadmat(filename)
    # Assuming 'all_k_nearest_neighbors' is the variable name in the MATLAB file
    neighbors_matrix = data['all_k_nearest_neighbors']
    
    # Convert to Python 0-based indexing if MATLAB indexing is 1-based
    neighbors_matrix = neighbors_matrix - 1
    
    # Initialize defaultdict
    neighbors_dict = defaultdict(list)
    
    # Populate the defaultdict with the data
    for idx, neighbors in enumerate(neighbors_matrix):
        neighbors_dict[idx] = neighbors.tolist()
    
    return neighbors_dict

def format_node_gnn(node_gnn):
    # Convert node_gnn to a NumPy array if it's not already one
    node_gnn_array = np.array(node_gnn)
    
    # # Check if the conversion was successful and the shape is as expected (1200 nodes, 6 dimensions)
    # if node_gnn_array.ndim == 2 and node_gnn_array.shape[1] == 6:
    #     print(f"Element 0: Type = {type(node_gnn_array)}")
    #     print(f"  Shape: {node_gnn_array.shape}")
    #     print("  Contents:")
    #     print(node_gnn_array)
    # else:
    #     print("The input does not match the expected format of 1200 nodes with 6 dimensions each.")
    return node_gnn_array
data_tuple=[]
base_path = 'data_gnn/data{}.mat'
filename_obstacles = 'obstacles/obstacle{}.pkl'
for k in range(1,2100):
    # filename = 'data_gnn/data1.mat'
    filename = base_path.format(k)

    # Load the .mat file
    # data = loadmat('nodes.mat', squeeze_me=True, struct_as_record=False)
    data = loadmat(filename, squeeze_me=True, struct_as_record=False)

    # Access the 'node_gnn' variable, ensuring it's correctly indexed
    node_gnn = data['node_gnn']

    # Preallocate a NumPy array to hold the 6-dimensional values for 1200 nodes
    node_values = np.zeros((1200, 6))

    # Loop through each node to extract its 'v' value
    for j in range(1200):
        # Assuming 'v' is directly accessible and properly structured
        node_values[j, :] = node_gnn[j].v  # Adjust if 'v' needs specific indexing
    node_numpy=format_node_gnn(node_values)

    # Load the data and convert it
    #filename = 'neighbors.mat'
    neighbors_dict = load_and_convert(filename)

    # # Display the required information
    # print(f"Type = {type(neighbors_dict)}")
    # print(f"Number of keys: {len(neighbors_dict)}")
    # print("First few key-value pairs:")
    # for i, (key, value) in enumerate(neighbors_dict.items()):
    #     if i < 50:  # Adjust this number to display more or fewer key-value pairs
    #         print(f"  Key: {key}, Value: {value}")
    #     else:
    #         break


    # Calculate the total number of edges
    total_edges = sum(len(neighbors) for neighbors in neighbors_dict.values())

    # Initialize the edge_index array
    edge_index = np.zeros((total_edges, 2), dtype=int)

    # Populate the edge_index array
    edge_counter = 0
    for node, neighbors in neighbors_dict.items():
        for neighbor in neighbors:
            edge_index[edge_counter] = [node, neighbor]
            edge_counter += 1

    # # Displaying the requested information
    # print(f"Element 3: Type = {type(edge_index)}")
    # print(f"  Shape: {edge_index.shape}")
    # print("  Contents:")
    # print(edge_index[:5], "\n ...")  # Display first 5 for brevity
    # print(edge_index[-3:], "\n")  # Display last 3 to show the structure continues as described

    # # Initialize edge_cost as a defaultdict of lists
    # edge_cost = defaultdict(list)

    # # Populate edge_cost with 'inf' for each neighbor of each node
    # for key, neighbors in neighbors_dict.items():
    #     edge_cost[key] = [math.inf for _ in neighbors]

    # # Display the requested information
    # print(f"Element 2: Type = {type(edge_cost)}")
    # print(f"Number of keys: {len(edge_cost)}")
    # print("First few key-value pairs:")
    # for i, (key, value) in enumerate(edge_cost.items()):
    #     if i < 5:  # Only display the first few key-value pairs for brevity
    #         print(f"  Key: {key}, Value: {value}")



        # Load the .mat file
    mat_contents = loadmat(filename)

    # Assuming 'edge_cost' is the variable in your .mat file
    edge_cost_mat = mat_contents['edge_cost']

    # Initialize a defaultdict to store the converted edge_cost
    edge_cost = defaultdict(list)

    # Populate the defaultdict with your data
    for i, row in enumerate(edge_cost_mat):
        # Assuming each row in your matrix corresponds to a key in your desired defaultdict
        # and each element in the row is a value for that key
        edge_cost[i] = list(row)  # Convert numpy array row to a list, which may contain 'inf' or finite values

    # # Example to print the format you described
    # print("Element 2: Type =", type(edge_cost))
    # print("Number of keys:", len(edge_cost))
    # print("First few key-value pairs:")
    # for key in list(edge_cost.keys())[:5]:  # Just showing the first 5 for brevity
    #     print(f"  Key: {key}, Value: {edge_cost[key]}")


    # Load the .mat file
    mat_data = loadmat(filename)

    # Extract the 'collision' variable from the loaded data
    collision = mat_data['collision']  # Assuming 'collision' is stored as a 1D array
    # Convert the numeric collision array to a boolean list (0 becomes False, 1 becomes True)
    collision_index = [bool(x) for x in collision]

    # # Display the requested information
    # print(f"Element 4: Type = {type(collision_index)}")
    # print(f"Length: {len(collision_index)}")
    # print(f"Contents: {collision_index[:5]} ...")  # Displaying the first 5 elements for brevity
    # Create a tuple with the specified elements
    data_tuple.append((node_numpy, neighbors_dict, edge_cost, edge_index, collision_index))

    data = loadmat(filename)

    # Access the variable from the .mat file
    obstacle = data['obstacles_gnn']

    # Assuming 'self' is part of a class structure, for this example, we'll directly use normalized_obstacles
    # self.obstacles = normalized_obstacles

    # Save the normalized_obstacles as a .pkl file
    pkl_file_path = filename_obstacles.format(k)
    with open(pkl_file_path, 'wb') as file:
        pickle.dump(obstacle, file)

# Serialize and save the tuple to a .pkl file
with open('data.pkl', 'wb') as file:
    pickle.dump(data_tuple, file)

# print("Data successfully saved to 'data.pkl'.")



# # Describing the content of each element in the tuple at index 0
# print("Details of tuple at index 0:\n")

# # Element 0: node_numpy
# print("Element 0: Type = {}".format(type(node_numpy)))
# print("  Shape: {}".format(node_numpy.shape))
# print("  Contents: {}".format(node_numpy[:5]), "\n ...")  # Simplified view

# # Element 1: neighbors_dict
# print("\nElement 1: Type = {}".format(type(neighbors_dict)))
# print("  Number of keys: {}".format(len(neighbors_dict)))
# print("  First few key-value pairs:")
# for i, (key, value) in enumerate(neighbors_dict.items()):
#     if i < 5:  # Display first few pairs
#         print(f"    Key: {key}, Value: {value}")

# # Element 2: edge_cost
# print("\nElement 2: Type = {}".format(type(edge_cost)))
# print("  Number of keys: {}".format(len(edge_cost)))
# print("  First few key-value pairs:")
# for i, (key, value) in enumerate(edge_cost.items()):
#     if i < 5:  # Display first few pairs
#         print(f"    Key: {key}, Value: {value}")

# # Element 3: edge_index
# print("\nElement 3: Type = {}".format(type(edge_index)))
# print("  Shape: {}".format(edge_index.shape))
# print("  Contents: {}".format(edge_index[:5]), "\n ...")  # Simplified view

# # Element 4: collision_index
# print("\nElement 4: Type = {}".format(type(collision_index)))
# print("  Length: {}".format(len(collision_index)))
# print("  Contents: {}".format(collision_index[:5]), " ...")  # Simplified view


